# 기본 문법

Rust 언어의 기본 문법을 소개하겠습니다. 이 책은 C 언어를 이미 사용해보신 분들을 대상으로 합니다. 변수라는게 뭔지, 함수라는게 뭔지 그런 일반적인 프로그래밍에 대한 설명은 생략하고, Rust 언어에 빠르게 적응하기 위해 필요한 사항들만 소개하겠습니다.

## 함수와 for 루프

FizzBuzz라는 함수를 만들어보겠습니다. 1부터 100까지의 숫자중에 3의 배수를 만나면 Fizz라고 출력하고 5의 배수를 만나면 Buzz라고 출력합니다. 만약에 3과 5의 공배수이면 FizzBuzz라고 출력합니다.

만약에 C만 경험해본 분이라면 아래와 같이 for문에 시작값과 종료 조건등을 생각해보시겠지만, 사실 C언어의 for문은 버그에 굉장히 취약한 형태입니다. "1부터 100까지의 숫자"라는 조건을 보고 다음처럼 생각하기 쉽습니다.

```c
for (i = 1; i < 100; i++)
```

이렇게하면 i가 100일때 처리를 하지 못하는데요 이런식으로 실수하기 쉬운 문법을 가지고 있습니다.

러스트에는 for문에 오직 이터레이터(Iterator)만 사용합니다. 파이선 언어와 유사하기도하고 최신 C++ 문법과도 유사합니다. for와 if만들 사용해서 최대한 C/C++이나 파이선 언어와 유사하게 만들어본 예제입니다.

```rust
fn fizzbuzz_if_else(max: i32) {
    for i in 1..=max {
        let rem_three: i32 = i % 3;
        let rem_five: i32 = i % 5;

        if rem_three == 0 && rem_five == 0 {
            println!("{} - FizzBuzz", i);
        } else if rem_three == 0 {
            println!("{} - Fizz", i);
        } else if rem_five == 0 {
            println!("{} - Buzz", i);
        } else {
						/* do nothing */
				}
    }
}
```

사실 마지막에 else는 아무것도 하지 않습니다만 이렇게 넣어줘야 완벽하게 모든 케이스를 처리하는 코드가 됩니다. else로 따로 할 일이 없다해도 else를 넣고 아무 처리를 하지 않는다는 코멘트라도 넣어줘야 보안에 신경쓴 코드가 됩니다. 이런 헛점을 러스트등의 최신 언어들은 놓치지않고 새로운 문법을 지원하고 있습니다. 러스트에서는 어떤 문법을 지원하는지도 추후에 설명하겠습니다.

따로 설명이 필요없을 정도로 간단합니다. 어떤 언어로든 프로그래밍을 해봤다면 쉽게 이해할 수 있습니다. 변수의 정의는 let 키워드를 사용합니다. 

```rust
let 변수이름: 타입 = 초기값;
```

함수의 정의를 fn 으로 시작합니다.

```rust
fn 함수이름(인자: 타입, 인자: 타입, ...) -> 반환값 {
	함수 라인1;
	라인2;
	걀과값
}
```

각 라인은 C/C++과 같이 “;”로 끝나야됩니다. 그리고 마지막에 함수 반환값은 “;”없이 쓰게됩니다. Scala등의 함수형 언어와 유사한 점입니다. 반환값이 없으면 안써주거나 반드시 반환값일 지정해야되는 경우 (if-else만 있는 함수같은 경우)에는 ()라고 써주기도 합니다.

한가지 주의해야할 점이 있다면 이터레이터를 사용하는 구문입니다. 러스트에서는 Range라는 타입으로 for문의 범위를 지정합니다만 지금은 크게 신경쓸 필요는 없습니다. 아래와 같이 작성하면 10을 제외한 9까지만 처리하는 코드가 됩니다. Bash나 몇몇 언어에서는 “1..10”이 10을 포함하지만 러스트에서는 10은 포함하지 않습니다.

```rust
for i in 1..10 {
......
}
```

1부터 10까지 처리하도록 하려면 다음과 같이 =를 추가해야합니다.

```rust
for i in 1..=10 {
......
}
```

### Exercises

1. 재귀 함수를 만들어서 1부터 10까지 수를 더하는 함수를 만들어보세요.

```rust
fn sum(start:i32, end: i32) -> i32 {
......
}
```

2. sum함수의 인자를 Range타입으로 바꾸고, 재귀 함수가 아니라 for문이나 loop문을 사용하도록 바꿔보세요.

## if 구문은 값을 가짐

C로 간단한 if-else 구문 사용 방법을 보겠습니다.

```c
#include <stdio.h>

int main() {
    int num = 5;
    int var;
    if (num % 3 == 0) {
        var = 3;
    } else if (num % 5 == 0) {
        var = 5;
    } else {
        var = 0;
    }
    printf("var=%d\n", var);
}
```

이 코드를 Rust로 변환하면 다음과 같이 만들 수 있습니다. 미리 주의해야할 것은 Rust에서 if-else문은 값을 가진다는 것입니다.

```rust
fn main() {
    let num = 5;
    let var = if num % 3 == 0 {
        3
    } else {
        if num % 5 == 0 {
            5
        } else {
            0
        }
    };
    println!("var = {}", var);
}
```

C에 익숙한 분들은 아마 아래와 같은 3항 연산자가 생각나실 겁니다.

```c
#include <stdio.h>

int main() {
    int num = 5;
    int var = num % 3 == 0 ? 3 : num % 5 == 0 ? 5 : 0;
    printf("var=%d\n", var);
}
```

C언어에서 위와 같은 3항 연산자는 구문 자체가 값을 반환하게 됩니다. C언어에서 if문이 러스트와 같이 반환값을 가질 수는 없지만 3항 연산자를 사용하면 러스트와 같이 좀더 짧고 에러 처리가 확실한 코드가 될 수 있습니다.

물론 러스트도 아래와 같이 C코드와 완전히 동일하게 구현할 수 있지만 추천하는 방식은 아닙니다.

```rust
fn main() {
    let num = 5;
    let var;
    if num % 3 == 0 {
        var = 3;
    } else if num % 5 == 0 {
        var = 5;
    } else {
        var = 0;
    }

    println!("var = {}", var);
}
```

왜 굳이 if문이 값을 가지도록 만들었을 까요? 프로그래밍 언어의 철학에 대해서 본격적으로 이야기하자면 저도 잘 모르는 깊은 이론들이 있겠지만, 제가 개발하면서 느꼈던 장점은 값이 초기화되지 않은 변수를 최소화할 수 있다는 것입니다. 초기화되지 않은 변수를 일부러 만드는 사람은 없을 것입니다. 하지만 코드가 길어지고 다른 사람의 코드를 유지보수하다보면 실수로 변수의 초기화 코드를 제거하기도 합니다. 그리고 아주 심각한 문제는 초기화가 안된 변수를 알아차리지 못하게 계속 사용하는 경우가 생길 수 있다는 것입니다.

```c
#include <stdio.h>

int main() {
    int num = 5;
    int var;
    if (num % 3 == 0) {
        var = 3;
    } else if (num % 5 == 0) {
        printf("This is error, please enter 3!\n");
    } else {
        var = 0;
    }
    printf("var=%d\n", var);
}
```

위 코드는 var변수를 초기화하는 것을 깜빡한 것입니다. if-else가 한두개이거나 처음 코딩할때는 초기화를 깜빡하지않겠지만, 개발이 점점 진행되고 코드가 길어지고 복잡해지면 초기화를 깜빡하는 경우가 자주 생깁니다. 운이 좋으면 그냥 쓰레기값이 출력되는 것으로 끝나겠지만, 대부분 의미없는 값이 이리저리 돌아다기나가 엉뚱한 곳에서 패닉을 발생시키고 디버깅하는데 며칠이 걸리게 만드는 경험을 해보셨을 것입니다.

러스트에서 if-else로 변수를 초기화하면 다음과 같이 값을 반환하지 않는 경우를 방지할 수 있습니다.

```rust
fn main() {
    let num = 5;
    let var = if num % 3 == 0 {
        3
    } else {
        if num % 5 == 0 {
            //5
            println!("Wrong number");
        } else {
            0
        }
    };
    println!("var = {}", var);
}

error[E0308]: `if` and `else` have incompatible types
  --> src/main.rs:10:13
   |
6  | /         if num % 5 == 0 {
7  | |             //5
8  | |             println!("Wrong number");
   | |             ------------------------ expected because of this
9  | |         } else {
10 | |             0
   | |             ^ expected `()`, found integer
11 | |         }
   | |_________- `if` and `else` have incompatible types
```

추가로 한가지 팁을 드리자면 러스트는 다양한 함수형 프로그래밍 기법을 사용하고 있어서 if-else를 사용할 일이 많이 줄어듭니다. C언어에서 if-else를 사용하는 처리를 Rust에서는 match나 map, filter등을 사용하는 경우가 훨씬 많습니다. 만약에 내 코드에 if-else가 많이 보인다면 Rust다운 코드를 만들지 못하고있는게 아닌가 자문해봐야합니다.

## Mutable 변수와 타입 추론

지금까지 우리가 만들어본 예제들은 변수가 생성될 때 값을 정하고 그 후에는 값을 바꾸지 않았었습니다.

```rust
fn fizzbuzz_if_else(max: i32) {
    for i in 1..=max {
        let rem_three: i32 = i % 3;
        let rem_five: i32 = i % 5;

        if rem_three == 0 && rem_five == 0 {
            println!("{} - FizzBuzz", i);
        } else if rem_three == 0 {
            println!("{} - Fizz", i);
        } else if rem_five == 0 {
            println!("{} - Buzz", i);
        } else {
						/* do nothing */
				}
    }
}
```

위 예제를 보면 3개의 변수가 있습니다. “let”으로 생성한 변수가 2개, rem_three, rem_five가 있고, 하나는 max라는 함수 인자입니다. 이렇게 총 3개의 변수가 하나의 함수를 이루는 컨텍스트에서 생성되었습니다.

함수의 컨텍스트는 간단하게 이해하자면 함수가 동작하기 위한 모든 메모리, 코드 등을 합쳐서 부르는 말입니다. 로컬 변수는 함수의 스택에 저장되고, 함수 인자는 함수를 호출하는 상위 함수의 메모리에 있겠지요. 그리고 함수 자체를 이루는 코드도 있을 것입니다. 이런 것들은 컨텍스트라고 생각할 수 있습니다.

어쩌면 지금까지의 예제 코드를 보면서 모든 변수들이 값이 고정된 변수들이었다는 것을 알아차리지 못한 분들도 계셨을 것입니다. 그게 바로 러스트가 변수 선언의 기본을 변하지않는 속성(Immutable)으로 정한 이유입니다. 생각외로 많은 변수들이 한번 초기화되면 값이 바뀌지 않습니다. 특히 함수형으로 코드를 작성하면 더욱 그런 경우가 많아지고요 그리고 함수들을 잘 분리해서 여러 함수들이 간결하게 작성되면 함수의 로컬 변수들의 값이 자주 바뀌지 않는 경우가 많습니다.

어쨌든 값이 변하는 변수를 만들고자할 때는 추가로 mut라는 키워드를 넣어주어야 합니다. 이것은 let으로 변수를 선언할 때 뿐 아니라 함수 인자에서도 마찬가지입니다.

mut 키워드를 사용하는 예제를 보겠습니다.

```rust
fn fib(mut index: i32) -> i32 {
    let mut a = 1;
    let mut b = 1;
    let mut t;

    loop {
        t = a + b;
        a = b;
        b = t;

        index -= 1;
        if index <= 0 {
            break;
        }
    }
    b
}
```

이 예제에서 3가지 새로운 컨셉을 소개하고 있습니다.

1. mut키워드를 사용해서 값이 변하는 변수와 함수 인자를 사용
2. loop 사용방법
3. 각 변수마다 일일이 타입을 안써줘도 러스트가 타입을 추론할 수 있음 (덕타이핑 Duck Typing이라고 부릅니다)

mut키워드는 mutable의 약자입니다. 값이 변하는 변수라는 표시인데요 보통의 프로그래밍 언어들이 값이 안변하는 상수를 위한 키워드가 있는 것에 비하면 반대로 러스트에서는 값이 안변하는 변수가 기본이고, 값이 변하는 변수가 mut 키워드를 추가해줘야합니다. 실제로 러스트로 프로그래밍하다보면 의외로 자주 mut 키워드를 빼먹어서 컴파일 에러가 나는 경우를 겪을 것입니다. 그런데 생각보다 더 많은 경우에 mut 키워드를 무의식적으로 빼먹고도 문제없이 동작하는 것을 겪을 것입니다. 저도 처음에는 mut 키워드를 써줘야한다는게 번거로울것 같았지만, 곧 제 자신이 값이 변하지 않는 변수를 생각보다 많이 써왔다는 것을 깨달았습니다. 그리고 좀 더 경험이 쌓일 수록 값이 바뀌지 않는 변수를 많이 사용하게되고 결국 코드가 조금 더 간결해지는 것을 경험하게 되었습니다. 물론 러스트가 가진 함수형 프로그래밍 기능들을 사용해서 그렇기도 합니다만 지금은 값이 변하지 않는 변수가 기본이라는 것이 코드의 안정성을 위해서 괸찬은 선택이었다고 생각힙다.

loop 사용법은 저 개인적으로 타 언어의 while 보다 더 편리하다고 생각합니다. while을 사용하다보면 while(..)의 ()안에 탈출 표현식을 써주고 또 while() {..} 바디안에 또 다른 탈출식을 써주게 되는 경우가 많습니다. 이것보다는 loop처럼 기본 탈출식이 없는게 좀 더 읽기 편하다고 생각합니다.

러스트는 타입 추론 기능을 가지고 있습니다. C++에서는 auto라는 타입을 써주면 컴파일러가 최적의 타입을 찾아주는데 러스트는 아예 타입을 안써줄 수도 있습니다. 러스트는 강타입 언어이므로 타입이 분명 존재합니다만, 타입을 안써주면 컴파일러 코드에서 변수의 사용을 보고 타입을 지정해줍니다. 이게 왜 편리하냐면 러스트의 문법 특성 상 타입이 아주 긴 경우가 자주있습니다.

아래와 같은 타입을 변수 타입에 써야한다면 번거로울 수밖에 없겠지요.

```rust
Box<dyn Fn() + Send + 'static>
Arc<Vec<Box<dyn Collector<dyn CollectorModel> + 'static>>>,
```
출처 link: https://doc.rust-lang.org/book/ch19-04-advanced-types.html

그리고 함수를 정의할 때는 타입을 생략할 수 없습니다.

## as를 이용한 타입 바꾸기

사실 C 언어가 가진 큰 단점중에 하나가 타입이 암묵적으로 바뀐다는 것입니다. C++은 C보다는 좀 더 엄격하게 타입이 바뀌는 것을 방지했지만, 그래도 대부분의 현대 언어들에 비하면 많이 느슨한 편입니다.

러스트는 타입 변환을 항상 명확하게 선언해주어야 합니다. 다음 예제 코드는 문자열로 된 숫자를 정수로 반환하는 함수입니다. 

```rust
fn string_to_digit(input: String) -> i32 {
    let mut ret = 0;
    for c in input.chars() {
        ret = ret * 10;
        ret += c as i32 - '0' as i32;
    }
    ret
}
```

함수 선언 부 외에는 변수의 타입을 지정하지 않았지만 c라는 변수가 char라는 타입인지 알 수 있습니다. 러스트에서 for문에는 항상 이터레이터만 사용할 수 있다고 설명했는데, String이라는 구조체의 chars라는 메소드가 문자열의 각 문자들을 반환하는 이터레이터를 생성해주는 메소드라고 생각하면 됩니다.

러스트에서는 char 타입의 변수 c에서 char 타입의 문자 ‘0’를 뺄 수는 없습니다. 현대 언어들에 익숙한 분들에게는 당연할 수도 있는 사항인데요, C 계열 언어에 익숙한 분들에게는 당황스러운 것일 수도 있습니다.

C 언어는 사실 어셈블리로 개발하던 프로젝트의 생산성을 높이기 위해 나온 언어입니다. 따라서 어셈블리가 익숙한 개발자들의 관점에서 디자인된 언어이다보니 모든게 숫자입니다. 참과 거짓도 숫자이고, 오류를 나타내는 NULL이나 에러 값도 숫자이고, 포인터도 숫자, char라는 타입도 숫자입니다. 그러니 더하기 빼기가 안될 수가 없지요. 하지만 이게 논리적으로 좋은 디자인이라는건 의문이 남습니다. 숫자가 아닌 타입을 더하거나 뺀다는건 논리적으로는 잘못된 연산이 되는게 더 옳지 않을까요.

잡설이 좀 길었지만 어쨌든 러스트에서는 타입의 변환을 as라는 키워드로 합니다. 추후에 몇가지 타입 변환과 관련된 키워드를 보겠지만 가장 기본적인 것은 바로 as 입니다. 러스트도 사실은 C 계열 개발자들의 생산성을 높이기 위해 나온 언어입니다. 이렇게 언어 자체에 키워드가 있어서 타입이 변환된다는 것도 논리적으로 옳은건지는 모르겠습니다만 Syntax sugar라고 생각해도 될듯합니다.

참고로 C언어에 atoi 라이브러리 함수가 있는 것처럼 러스트에도 이미 같은 일을 하는 라이브러리 함수가 있습니다.

```rust
fn parse_example(input: &str) -> Result<i32, ParseIntError> {
    input.parse()
}

fn main() {
    let ret = parse_example("1234");
    match ret {
        Ok(value) => {
            println!("Parsed integer: {}", value);
        }
        Err(_) => {
            println!("Failed to parse the string as an integer");
        }
    }
}
```

string_to_digit 함수의 문제점은 문자열이 숫자 외의 문자를 가지고있는 등의 에러 상황에서 에러 값을 반환할 수가 없다는 것입니다. 에러 값을 반환하기 위해서 함수 인자에 결과값에 대한 포인터를 전달하거나 하면 코드가 복잡해지게됩니다. C 언어의 디자인 단계에서부터 실수한 것이 바로 에러 값에 대한 처리가 없다는 것입니다.

러스트는 에러 값으로 Result나 Option같은 타입을 사용하게 됩니다. 추후에 좀 더 자세히 알아볼 것인데 미리 이런 상황에서 필요하다는 것을 알고 넘어가면 나중에 좀 더 이해하기 쉬울것 같아서 예제를 만들어보았습니다.