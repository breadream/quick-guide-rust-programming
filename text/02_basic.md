# 기본 문법

Rust 언어의 기본 문법을 소개하겠습니다. 이 책은 C 언어를 이미 사용해보신 분들을 대상으로 합니다. 변수라는게 뭔지, 함수라는게 뭔지 그런 일반적인 프로그래밍에 대한 설명은 생략하고, Rust 언어에 빠르게 적응하기 위해 필요한 사항들만 소개하겠습니다.

## 함수와 for 루프

FizzBuzz라는 함수를 만들어보겠습니다. 1부터 100까지의 숫자중에 3의 배수를 만나면 Fizz라고 출력하고 5의 배수를 만나면 Buzz라고 출력합니다. 만약에 3과 5의 공배수이면 FizzBuzz라고 출력합니다.

만약에 C만 경험해본 분이라면 아래와 같이 for문에 시작값과 종료 조건등을 생각해보시겠지만, 사실 C언어의 for문은 버그에 굉장히 취약한 형태입니다. "1부터 100까지의 숫자"라는 조건을 보고 다음처럼 생각하기 쉽습니다.

```c
for (i = 1; i < 100; i++)
```

이렇게하면 i가 100일때 처리를 하지 못하는데요 이런식으로 실수하기 쉬운 문법을 가지고 있습니다.

러스트에는 for문에 오직 이터레이터(Iterator)만 사용합니다. 파이선 언어와 유사하기도하고 최신 C++ 문법과도 유사합니다. for와 if만들 사용해서 최대한 C/C++이나 파이선 언어와 유사하게 만들어본 예제입니다.

```rust
fn fizzbuzz_if_else(max: i32) {
    for i in 1..=max {
        let rem_three: i32 = i % 3;
        let rem_five: i32 = i % 5;

        if rem_three == 0 && rem_five == 0 {
            println!("{} - FizzBuzz", i);
        } else if rem_three == 0 {
            println!("{} - Fizz", i);
        } else if rem_five == 0 {
            println!("{} - Buzz", i);
        } else {
						/* do nothing */
				}
    }
}
```

사실 마지막에 else는 아무것도 하지 않습니다만 이렇게 넣어줘야 완벽하게 모든 케이스를 처리하는 코드가 됩니다. else로 따로 할 일이 없다해도 else를 넣고 아무 처리를 하지 않는다는 코멘트라도 넣어줘야 보안에 신경쓴 코드가 됩니다. 이런 헛점을 러스트등의 최신 언어들은 놓치지않고 새로운 문법을 지원하고 있습니다. 러스트에서는 어떤 문법을 지원하는지도 추후에 설명하겠습니다.

따로 설명이 필요없을 정도로 간단합니다. 어떤 언어로든 프로그래밍을 해봤다면 쉽게 이해할 수 있습니다. 변수의 정의는 let 키워드를 사용합니다. 

```rust
let 변수이름: 타입 = 초기값;
```

함수의 정의를 fn 으로 시작합니다.

```rust
fn 함수이름(인자: 타입, 인자: 타입, ...) -> 반환값 {
	함수 라인1;
	라인2;
	걀과값
}
```

각 라인은 C/C++과 같이 “;”로 끝나야됩니다. 그리고 마지막에 함수 반환값은 “;”없이 쓰게됩니다. Scala등의 함수형 언어와 유사한 점입니다. 반환값이 없으면 안써주거나 반드시 반환값일 지정해야되는 경우 (if-else만 있는 함수같은 경우)에는 ()라고 써주기도 합니다.

한가지 주의해야할 점이 있다면 이터레이터를 사용하는 구문입니다. 러스트에서는 Range라는 타입으로 for문의 범위를 지정합니다만 지금은 크게 신경쓸 필요는 없습니다. 아래와 같이 작성하면 10을 제외한 9까지만 처리하는 코드가 됩니다. Bash나 몇몇 언어에서는 “1..10”이 10을 포함하지만 러스트에서는 10은 포함하지 않습니다.

```rust
for i in 1..10 {
......
}
```

1부터 10까지 처리하도록 하려면 다음과 같이 =를 추가해야합니다.

```rust
for i in 1..=10 {
......
}
```

## if 구문은 값을 가짐

C로 간단한 if-else 구문 사용 방법을 보겠습니다.

```c
#include <stdio.h>

int main() {
    int num = 5;
    int var;
    if (num % 3 == 0) {
        var = 3;
    } else if (num % 5 == 0) {
        var = 5;
    } else {
        var = 0;
    }
    printf("var=%d\n", var);
}
```

이 코드를 Rust로 변환하면 다음과 같이 만들 수 있습니다. 미리 주의해야할 것은 Rust에서 if-else문은 값을 가진다는 것입니다.

```rust
fn main() {
    let num = 5;
    let var = if num % 3 == 0 {
        3
    } else {
        if num % 5 == 0 {
            5
        } else {
            0
        }
    };
    println!("var = {}", var);
}
```

C에 익숙한 분들은 아마 아래와 같은 3항 연산자가 생각나실 겁니다.

```c
#include <stdio.h>

int main() {
    int num = 5;
    int var = num % 3 == 0 ? 3 : num % 5 == 0 ? 5 : 0;
    printf("var=%d\n", var);
}
```

C언어에서 위와 같은 3항 연산자는 구문 자체가 값을 반환하게 됩니다. C언어에서 if문이 러스트와 같이 반환값을 가질 수는 없지만 3항 연산자를 사용하면 러스트와 같이 좀더 짧고 에러 처리가 확실한 코드가 될 수 있습니다.

물론 러스트도 아래와 같이 C코드와 완전히 동일하게 구현할 수 있지만 추천하는 방식은 아닙니다.

```rust
fn main() {
    let num = 5;
    let var;
    if num % 3 == 0 {
        var = 3;
    } else if num % 5 == 0 {
        var = 5;
    } else {
        var = 0;
    }

    println!("var = {}", var);
}
```

왜 굳이 if문이 값을 가지도록 만들었을 까요? 프로그래밍 언어의 철학에 대해서 본격적으로 이야기하자면 저도 잘 모르는 깊은 이론들이 있겠지만, 제가 개발하면서 느꼈던 장점은 값이 초기화되지 않은 변수를 최소화할 수 있다는 것입니다. 초기화되지 않은 변수를 일부러 만드는 사람은 없을 것입니다. 하지만 코드가 길어지고 다른 사람의 코드를 유지보수하다보면 실수로 변수의 초기화 코드를 제거하기도 합니다. 그리고 아주 심각한 문제는 초기화가 안된 변수를 알아차리지 못하게 계속 사용하는 경우가 생길 수 있다는 것입니다.

```c
#include <stdio.h>

int main() {
    int num = 5;
    int var;
    if (num % 3 == 0) {
        var = 3;
    } else if (num % 5 == 0) {
        printf("This is error, please enter 3!\n");
    } else {
        var = 0;
    }
    printf("var=%d\n", var);
}
```

위 코드는 var변수를 초기화하는 것을 깜빡한 것입니다. if-else가 한두개이거나 처음 코딩할때는 초기화를 깜빡하지않겠지만, 개발이 점점 진행되고 코드가 길어지고 복잡해지면 초기화를 깜빡하는 경우가 자주 생깁니다. 운이 좋으면 그냥 쓰레기값이 출력되는 것으로 끝나겠지만, 대부분 의미없는 값이 이리저리 돌아다기나가 엉뚱한 곳에서 패닉을 발생시키고 디버깅하는데 며칠이 걸리게 만드는 경험을 해보셨을 것입니다.

러스트에서 if-else로 변수를 초기화하면 다음과 같이 값을 반환하지 않는 경우를 방지할 수 있습니다.

```rust
fn main() {
    let num = 5;
    let var = if num % 3 == 0 {
        3
    } else {
        if num % 5 == 0 {
            //5 missing by mistake
            println!("Wrong number");
        } else {
            0
        }
    };
    println!("var = {}", var);
}

error[E0308]: `if` and `else` have incompatible types
  --> src/main.rs:10:13
   |
6  | /         if num % 5 == 0 {
7  | |             //5 missing by mistake
8  | |             println!("Wrong number");
   | |             ------------------------ expected because of this
9  | |         } else {
10 | |             0
   | |             ^ expected `()`, found integer
11 | |         }
   | |_________- `if` and `else` have incompatible types
```

추가로 한가지 팁을 드리자면 러스트는 다양한 함수형 프로그래밍 기법을 사용하고 있어서 if-else를 사용할 일이 많이 줄어듭니다. C언어에서 if-else를 사용하는 처리를 Rust에서는 match나 map, filter등을 사용하는 경우가 훨씬 많습니다. 만약에 내 코드에 if-else가 많이 보인다면 Rust다운 코드를 만들지 못하고있는게 아닌가 자문해봐야합니다.

## Mutable 변수와 타입 추론

지금까지 우리가 만들어본 예제들은 변수가 생성될 때 값을 정하고 그 후에는 값을 바꾸지 않았었습니다.

```rust
fn fizzbuzz_if_else(max: i32) {
    for i in 1..=max {
        let rem_three: i32 = i % 3;
        let rem_five: i32 = i % 5;

        if rem_three == 0 && rem_five == 0 {
            println!("{} - FizzBuzz", i);
        } else if rem_three == 0 {
            println!("{} - Fizz", i);
        } else if rem_five == 0 {
            println!("{} - Buzz", i);
        } else {
						/* do nothing */
				}
    }
}
```

위 예제를 보면 3개의 변수가 있습니다. “let”으로 생성한 변수가 2개, rem_three, rem_five가 있고, 하나는 max라는 함수 인자입니다. 이렇게 총 3개의 변수가 하나의 함수를 이루는 컨텍스트에서 생성되었습니다.

함수의 컨텍스트는 간단하게 이해하자면 함수가 동작하기 위한 모든 메모리, 코드 등을 합쳐서 부르는 말입니다. 로컬 변수는 함수의 스택에 저장되고, 함수 인자는 함수를 호출하는 상위 함수의 메모리에 있겠지요. 그리고 함수 자체를 이루는 코드도 있을 것입니다. 이런 것들은 컨텍스트라고 생각할 수 있습니다.

어쩌면 지금까지의 예제 코드를 보면서 모든 변수들이 값이 고정된 변수들이었다는 것을 알아차리지 못한 분들도 계셨을 것입니다. 그게 바로 러스트가 변수 선언의 기본을 변하지않는 속성(Immutable)으로 정한 이유입니다. 생각외로 많은 변수들이 한번 초기화되면 값이 바뀌지 않습니다. 특히 함수형으로 코드를 작성하면 더욱 그런 경우가 많아지고요 그리고 함수들을 잘 분리해서 여러 함수들이 간결하게 작성되면 함수의 로컬 변수들의 값이 자주 바뀌지 않는 경우가 많습니다.

어쨌든 값이 변하는 변수를 만들고자할 때는 추가로 mut라는 키워드를 넣어주어야 합니다. 이것은 let으로 변수를 선언할 때 뿐 아니라 함수 인자에서도 마찬가지입니다.

mut 키워드를 사용하는 예제를 보겠습니다.

```rust
fn fib(mut index: i32) -> i32 {
    let mut a = 1;
    let mut b = 1;
    let mut t;

    loop {
        t = a + b;
        a = b;
        b = t;

        index -= 1;
        if index <= 0 {
            break;
        }
    }
    b
}
```

이 예제에서 3가지 새로운 컨셉을 소개하고 있습니다.

1. mut키워드를 사용해서 값이 변하는 변수와 함수 인자를 사용
2. loop 사용방법
3. 각 변수마다 일일이 타입을 안써줘도 러스트가 타입을 추론할 수 있음 (덕타이핑 Duck Typing이라고 부릅니다)

mut키워드는 mutable의 약자입니다. 값이 변하는 변수라는 표시인데요 보통의 프로그래밍 언어들이 값이 안변하는 상수를 위한 키워드가 있는 것에 비하면 반대로 러스트에서는 값이 안변하는 변수가 기본이고, 값이 변하는 변수가 mut 키워드를 추가해줘야합니다. 실제로 러스트로 프로그래밍하다보면 의외로 자주 mut 키워드를 빼먹어서 컴파일 에러가 나는 경우를 겪을 것입니다. 그런데 생각보다 더 많은 경우에 mut 키워드를 무의식적으로 빼먹고도 문제없이 동작하는 것을 겪을 것입니다. 저도 처음에는 mut 키워드를 써줘야한다는게 번거로울것 같았지만, 곧 제 자신이 값이 변하지 않는 변수를 생각보다 많이 써왔다는 것을 깨달았습니다. 그리고 좀 더 경험이 쌓일 수록 값이 바뀌지 않는 변수를 많이 사용하게되고 결국 코드가 조금 더 간결해지는 것을 경험하게 되었습니다. 물론 러스트가 가진 함수형 프로그래밍 기능들을 사용해서 그렇기도 합니다만 지금은 값이 변하지 않는 변수가 기본이라는 것이 코드의 안정성을 위해서 괸찬은 선택이었다고 생각힙다.

loop 사용법은 저 개인적으로 타 언어의 while 보다 더 편리하다고 생각합니다. while을 사용하다보면 while(..)의 ()안에 탈출 표현식을 써주고 또 while() {..} 바디안에 또 다른 탈출식을 써주게 되는 경우가 많습니다. 이것보다는 loop처럼 기본 탈출식이 없는게 좀 더 읽기 편하다고 생각합니다.

러스트는 타입 추론 기능을 가지고 있습니다. C++에서는 auto라는 타입을 써주면 컴파일러가 최적의 타입을 찾아주는데 러스트는 아예 타입을 안써줄 수도 있습니다. 러스트는 강타입 언어이므로 타입이 분명 존재합니다만, 타입을 안써주면 컴파일러 코드에서 변수의 사용을 보고 타입을 지정해줍니다. 이게 왜 편리하냐면 러스트의 문법 특성 상 타입이 아주 긴 경우가 자주있습니다.

아래와 같은 타입을 변수 타입에 써야한다면 번거로울 수밖에 없겠지요.

```rust
Box<dyn Fn() + Send + 'static>
Arc<Vec<Box<dyn Collector<dyn CollectorModel> + 'static>>>,
```
출처 link: https://doc.rust-lang.org/book/ch19-04-advanced-types.html

그리고 함수를 정의할 때는 타입을 생략할 수 없습니다.

## as를 이용한 타입 바꾸기

사실 C 언어가 가진 큰 단점중에 하나가 타입이 암묵적으로 바뀐다는 것입니다. C++은 C보다는 좀 더 엄격하게 타입이 바뀌는 것을 방지했지만, 그래도 대부분의 현대 언어들에 비하면 많이 느슨한 편입니다.

러스트는 타입 변환을 항상 명확하게 선언해주어야 합니다. 다음 예제 코드는 문자열로 된 숫자를 정수로 반환하는 함수입니다. 

```rust
fn string_to_digit(input: String) -> i32 {
    let mut ret = 0;
    for c in input.chars() {
        ret = ret * 10;
        ret += c as i32 - '0' as i32;
    }
    ret
}
```

함수 선언 부 외에는 변수의 타입을 지정하지 않았지만 c라는 변수가 char라는 타입인지 알 수 있습니다. 러스트에서 for문에는 항상 이터레이터만 사용할 수 있다고 설명했는데, String이라는 구조체의 chars라는 메소드가 문자열의 각 문자들을 반환하는 이터레이터를 생성해주는 메소드라고 생각하면 됩니다.

러스트에서는 char 타입의 변수 c에서 char 타입의 문자 ‘0’를 뺄 수는 없습니다. 현대 언어들에 익숙한 분들에게는 당연할 수도 있는 사항인데요, C 계열 언어에 익숙한 분들에게는 당황스러운 것일 수도 있습니다.

C 언어는 사실 어셈블리로 개발하던 프로젝트의 생산성을 높이기 위해 나온 언어입니다. 따라서 어셈블리가 익숙한 개발자들의 관점에서 디자인된 언어이다보니 모든게 숫자입니다. 참과 거짓도 숫자이고, 오류를 나타내는 NULL이나 에러 값도 숫자이고, 포인터도 숫자, char라는 타입도 숫자입니다. 그러니 더하기 빼기가 안될 수가 없지요. 하지만 이게 논리적으로 좋은 디자인이라는건 의문이 남습니다. 숫자가 아닌 타입을 더하거나 뺀다는건 논리적으로는 잘못된 연산이 되는게 더 옳지 않을까요.

잡설이 좀 길었지만 어쨌든 러스트에서는 타입의 변환을 as라는 키워드로 합니다. 추후에 몇가지 타입 변환과 관련된 키워드를 보겠지만 가장 기본적인 것은 바로 as 입니다. 러스트도 사실은 C 계열 개발자들의 생산성을 높이기 위해 나온 언어입니다. 이렇게 언어 자체에 키워드가 있어서 타입이 변환된다는 것도 논리적으로 옳은건지는 모르겠습니다만 Syntax sugar라고 생각해도 될듯합니다.

참고로 C언어에 atoi 라이브러리 함수가 있는 것처럼 러스트에도 이미 같은 일을 하는 라이브러리 함수가 있습니다.

```rust
fn parse_example(input: &str) -> Result<i32, ParseIntError> {
    input.parse()
}

fn main() {
    let ret = parse_example("1234");
    match ret {
        Ok(value) => {
            println!("Parsed integer: {}", value);
        }
        Err(_) => {
            println!("Failed to parse the string as an integer");
        }
    }
}
```

string_to_digit 함수의 문제점은 문자열이 숫자 외의 문자를 가지고있는 등의 에러 상황에서 에러 값을 반환할 수가 없다는 것입니다. 에러 값을 반환하기 위해서 함수 인자에 결과값에 대한 포인터를 전달하거나 하면 코드가 복잡해지게됩니다. C 언어의 디자인 단계에서부터 실수한 것이 바로 에러 값에 대한 처리가 없다는 것입니다.

러스트는 에러 값으로 Result나 Option같은 타입을 사용하게 됩니다. 추후에 좀 더 자세히 알아볼 것인데 미리 이런 상황에서 필요하다는 것을 알고 넘어가면 나중에 좀 더 이해하기 쉬울것 같아서 예제를 만들어보았습니다.

## 패턴 매칭

러스트의 기본 문법들은 대부분 C에서 가저오거나 최신 함수형 언어들에서 가져온 것들이라 개발 경력이 조금 있는 분들은 금방 익숙해질 수 있습니다. 그러다가 처음으로 흥미를 느끼는 문법이 바로 패턴 매칭 부분입니다. 간단하게 생각하면 if-else가 여러개 있는 케이스나 C에서 switch문으로 작성하는 케이스들을 좀더 간단하게 만들어 줬다고 생각할 수 있습니다.

패턴 매칭은 사실 엄격한 정의가 있다기 보다는 쓰다보면서 적응해나가는게 더 효율적인 접근방법이라고 생각합니다. 일단 가장 쉬운 예제를 하나 보겠습니다. 이전에 만든 fizzbuzz 예제를 패턴 매칭으로 바꿔보았습니다.

```rust
fn fizzbuzz_2(max: i32) {
    for i in 1..=max {
        match (i % 3, i % 5) {
            (0, 0) => println!("{} - FizzBuzz", i),
            (0, _) => println!("{} - Fizz", i),
            (_, 0) => println!("{} - Buzz", i),
            (_, _) => (),
        }
    }
}
```

위의 예제를 보면 (i % 3, i % 5) 는 하나의 튜플 Tuples를 만든 것입니다. 이 튜플의 값이 각 패턴에 해당될 때 다른 메세지를 출력하도록 만든 것입니다. 언더바 _ 는 모든 값을 의미합니다. 튜플의 값을 비교해야하는데 두개의 값이 있어야 하므로 하나는 0이고 다른 값은 무엇이든 상관없을 때 언더바를 사용한 것입니다. 패턴 매칭이므로 2개의 값이 있는 튜플의 패턴을 매칭하려면 2개의 값이 있어야된다는 것을 주의해야합니다.

if-else를 쓸 때와 마찬가지로 패턴의 비교 순서가 바뀌면 전혀 다른 결과를 만들어냅니다. 만약에 아래처럼 패턴 순서를 바꿨다면 어떤 일이 벌어질까요?

```rust
fn fizzbuzz_2(max: i32) {
    for i in 1..=max {
        match (i % 3, i % 5) {
            (0, _) => println!("{} - Fizz", i),
            (_, 0) => println!("{} - Buzz", i),
            (0, 0) => println!("{} - FizzBuzz", i),
            (_, _) => (),
        }
    }
}
```

만약 튜플 값이 (0, 0)이면 FizzBuzz를 출력하는게 아니라 Fizz를 출력할 것입니다.

흔하게 사용하는 패턴을 하나 더 보겠습니다. 어떤 변수의 값이 어느 범위에 속하는지 판단하는 코드입니다.

```rust
let gen = match age {
    0..=20 => "MZ",
    21..=50 => "X",
    51..=100 => "A",
    _ => "?",
};
```

age라는 변수를 0..20이라는 Range타입과 비교하는 것인데, 문법적으로 세세하게 따지면 복잡할 수도 있는 코드입니다만 지금은 이런 것도 가능하다 정도로 생각하고 일단 자주 활용하면서 익숙해지면 될듯 합니다. 단순히 age라는 변수의 범위만 따지는게 아니라 각 경우에 따른 반환 값을 gen이라는 변수를 생성하는데 사용한 것을 주의해서 보시기 바랍니다.

단순히 패턴에 일치하는 것만 확인하는게 아니라 아래와 같이 if와 결합해서 조건식을 써줄 수도 있습니다. 

```rust
for i in 1..=100 {
    let msg = match i {
        n if n % 15 == 0 => format!("{} - FizzBizz", n),
        n if n % 3 == 0 => format!("{} - Fizz", n),
        n if n % 5 == 0 => format!("{} - Buzz", n),
        _ => format!("{}", i),
    };
    println!("{}", msg);
};
```

format!()은 문자열 객체를 반환해주는 매크로 함수입니다.

러스트 관련 소개 자료나 공식 문서등을 보면 러스트의 패턴 매칭은 강력하다라는 설명이 있습니다. 보통 강력하다라는 말은 응용되는 케이스가 많다는 의미입니다. 러스트로 개발하다보면 이런것도 되네 하면서 감탄하는 경험을 하게되실 것입니다.

## 러스트의 표현식

if-else나 패턴 매칭의 예제를 보면 변수를 선언하는 부분에 복잡한 코드를 넣은 것을 볼 수 있습니다.

```rust
let gen = match age {
    0..=20 => "MZ",
    21..=50 => "X",
    51..=100 => "A",
    _ => "?",
};

let var = if num % 3 == 0 {
    3
} else {
    if num % 5 == 0 {
        5
    } else {
        0
    }
};
```

match를 이용한 패턴 매칭 구문에서 { 로 시작하고 } 로 끝나는 하나의 블럭을 표현식Expressions 라고 합니다. 마찬가지로 if-else도 하나의 표현식입니다.

그리고 표현식은 값을 반환합니다.

값을 반환하는건 무엇이 있나요? 함수가 있습니다. 함수도 하나의 표현식입니다.

```rust
fn ret_zero() -> i32 {
    0
}
```

함수도 {와 }로 시작과 끝을 나타내고 반환값을 마지막에 써놓은 표현식입니다.

위 예제의 if-else도 각 {} 블럭 안에 반환값이 정해져있습니다.

그리고 match 구문에서도 각 상황에 따른 반환값이 있습니다.

이 표현식은 ;를 만나면 그 반환값이 무시됩니다. 그래서 아래와 같은 변수 초기화 코드가 만들어질 수 있게됩니다.

```rust
let y = {
        let x_squared = x * x;
        let x_cube = x_squared * x;

        // This expression will be assigned to `y`
        x_cube + x_squared + x
    };
```

y라는 변수의 값을 계산하기 위해 복잡한 코드가 나열되는게 아니라 y의 선언부에 모여있을 수 있습니다. 물론 위에서 본것과 같이 match, if-else등 도 올 수 있습니다. 다른 언어와 마찬가지로 당연히 함수 호출도 올 수 있겠지요.

참고로 원어로 표현식은 Expression이고 표현식에 ;가 붙은 것을 Statement라고 구분해서 부르는 경우도 있습니다.

## 배열과 슬라이스

문자열을 사용하는 예제를 봤으니 우선 배열과 슬라이스에 대해서 알아본 후 본격적으로 문자열(사실은 문자열이라기 보다는 String 객체가 맞는 표현입니다만)을 알아보겠습니다.

배열은 간단합니다. 같은 타입의 데이터가 메모리에 연속적으로 나열된 데이터 구조를 말합니다.

```rust
let numbers: [i32; 5] = [1, 2, 3, 4, 5]; // Example array of numbers
```

위와 같이 i32이라는 같은 타입의 데이터가 연속적으로 5개가 메모리에 연속적으로 저장되어있습니다. 메모리에 연속적으로 위치하고있기 때문에 우리는 numbers[0] 다음에 있는 데이터가 numbers[0]의 위치(포인터)에서 i32타입의 크기, 4만큼 더한 곳에 위치한다는 것을 알 수 있습니다.

```
numbers[0] ==> 0x100
numbers[1] ==> 0x100 + 1 * 4 = 0x104
...
numbers[i] ==> 0x100 + i * 4
```

그래서 배열의 인덱스 [0], [1]을 가지고 빠르게 각 데이터에 접근할 수 있습니다.

슬라이스는 이런 배열의 일부(혹은 전체)만을 접근하려고 만든 레퍼런스 타입입니다.

```rust
let slice: &[i32] = &numbers[1..4]; // Create a slice from index 1 to 3 (inclusive)
```

위의 슬라이스는 numbers라는 배열의 1,2,3번 데이터에만 접근할 수 있습니다. [i32]는 배열이고 참조 연산자 &를 써서 배열의 참조라는 것을 나타냅니다. 

여기서 배열이나 구조체같은 여러 데이터가 같이 묶여있는 타입의 디버깅을 위해 좋은 방법을 소개하겠습니다.

```rust
fn main() {
    let numbers: [i32; 5] = [1, 2, 3, 4, 5]; // Example array of numbers

    let slice: &[i32] = &numbers[1..4]; // Create a slice from index 1 to 3 (inclusive)

    println!("Array: {:?}", numbers);
    println!("Slice: {:?}", slice);
}
```

“{:?}”라는 출력 포맷을 사용하면 아래와 같이 배열의 데이터를 전부 출력해줍니다.

```rust
Array: [1, 2, 3, 4, 5]
Slice: [2, 3, 4]
```

나중에 배울 구조체도 같은 방법으로 구조체의 각 데이터 필드를 출력할 수 있습니다.

어쨌든 슬라이스를 통해 3개의 데이터만 접근할 수 있는 것을 알 수 있습니다. 배열의 참조이지만, 슬라이스라는 타입 내부에는 이 슬라이스가 몇개의 데이터를 참조할 수 있는지에 대한 정보가 같이 저장되어있다고 보시면 됩니다. 그래서 슬라이스의 데이터를 전부 출력해보면 3개만 출력되는 것입니다.

슬라이스가 뭔지는 알았는데 그럼 슬라이스가 왜 필요한지가 의문일 수 있습니다. 왜냐면 C언어에는 슬라이스가 없기 때문입니다. 배열이나 구조체가 존재하는 메모리를 읽다가 그 다음 메모리까지 읽는 것을 방지할 수 없는게  C언어입니다. numbers[5]를 읽거나 쓰려는 실수를 누구나 해본적이 있을 것입니다.

슬라이스는 바로 이런 실수를 방지하려고 있는 것입니다. 함수나 쓰레드를 호출 할 때, 그 함수나 쓰레드가 배열의 일부분에만 접근해야한다고 할 때, 배열 전체를 전달하는게 아니라 슬라이스를 전달하게됩니다.

위에서 슬라이스는 배열의 일부 혹은 전체에 접근하기 위한 타입이라고 설명했습니다. 다음 예제를 보겠습니다.

```rust
fn sum_array_ref(nums: &[i32]) -> i32 {
    let mut s = 0;
    let len = nums.len();
    let mut index = 0;
    loop {
        if index >= len {
            return s;
        }
        s += nums[index];
        index += 1;
    }
}

fn sum_slice(nums: &[i32]) -> i32 {
    let mut s = 0;
    for i in nums.iter() {
        s += i;
    }
    s
}

fn main() {
   let numbers: [i32; 5] = [1,2,3,4,5];
   let slice = &numbers[1..4];

   println!("{}", sum_array_ref(&numbers));
   println!("{}", sum_slice(slice));
}
``` 

sum_array_ref는 배열을 참조로 전달받는 함수이고,  sum_slice는 슬라이스를 전달받는 함수입니다. 당연히 슬라이스가 배열의 참조이므로 형태가 동일합니다. 각 함수는 자신이 전달받은 데이터가 배열의 참조인지, 배열의 일부분을 가르키는 슬라이스인지 알 수가 없습니다. 사실 구분할 필요도 없는 것입니다.

배열이나 문자열을 처리하는 함수를 만들 때는 항상 슬라이스로 인자를 받도록 만드는 습관을 가지면 좋습니다.

물론 슬라이스같은 참조가 아니라 배열이나 문자열을 그대로 전달하면 소유권까지 함수로 넘어가게되서 함수를 호출한 코드에서 다시는 배열이나 문자열을 접근할 수 없게되기 때문에, 그렇게 슬라이스로 처리를 할 수 밖에 없습니다. 러스트의 소유권 개념은 너무나 유명해서 아마 한두번은 들어보셨을 것입니다. 어쨌든 러스트는 이렇게 사용자가 실수할 수 있는 부분들을 최대한 막으려는 디자인 철학을 가진 언어입니다. C의 문제점들을 해결하려고 C++에서 수십차례 버전을 올려가며 규약들을 만들고, 스마트 포인터를 만드는 등의 노력을 했었지만, 근본적으로 언어의 철학 자체가 개발자가 모든 것을 직접 처리할 수 있어야 한다는 철학을 밑바탕에 가지고 있기 때문에 완전히 막을 수 없는 헛점들이 있었습니다. 러스트는 그런 C++의 최신 기법들을 모두 모아놓고, 강제로 쓰도록 정해놓았다고 이해를 해되 된다고 생각합니다.